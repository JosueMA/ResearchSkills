trueR <- 3.7
trueRArray <- seq(from=3.2, to=3.9, length.out=50) # for reproducing Fig S.1
trueK <- 1
trueN0 <- 0.5
sampleSize <- 50
trueprocerror <- 0.005
trueObsErrSD <- sqrt(1/25.5) # approx. 0.1980295
logistic <- function(K,r,N0,samplesize){
pop = rep(NA,(samplesize))
pop[1] = N0
for (i in 2:(samplesize)){
pop[i] = pop[i-1] * r * (1 - pop[i-1]/K) * rlnorm(1,0,trueprocerror)
}
return(pmax(0,pop))
}
truepops <- matrix(nrow = 100, ncol = 2*sampleSize)
observedpops <- matrix(nrow = 100, ncol = 2*sampleSize)
truepops2 <- matrix(nrow = 50, ncol = 2*sampleSize)
observedpops2 <- matrix(nrow = 50, ncol = 2*sampleSize)
# 100 population dynamics with fixed r=3.7, to reproduce results of Figs.S5,S6,
# as well as all results regarding predictive accuracy of the logistic model such
# as Fig 1A
for (i in 1:100){
pop <- logistic(trueK,trueR,trueN0,2*sampleSize)
truepops[i,] <- pop
observedpops[i,] =rlnorm(length(pop), mean = log(pop) , sd = trueObsErrSD)
}
# 50 population dynamics with varying R, to reproduce Fig S1, S2
for (i in 1:50){
pop <- logistic(trueK,trueRArray[i],trueN0,2*sampleSize)
truepops2[i,] <- pop
observedpops2[i,] =rlnorm(length(pop), mean = log(pop) , sd = trueObsErrSD)
}
#Testing
pop <- truepops[1,]
observed <- observedpops[1,]
plot(observed, xlab = "Time interval", ylab = "Population Size / K", main = "Population Dynamics r=3.7", ylim=c(0,2))
lines(pop)
########################################################################
# Reimplementation of the bugs model from Perretti et al. (with slight
# modifications, max() statement changed, changed to mathematical identical
# slnorm specifications)
sink("model.txt")
cat(
"model{
r ~ dunif(1,5)
K ~ dunif(0.5,1.5)
ProcessPrecision <- 1/0.005/0.005
ObservationPrecision ~ dunif(1,40)
obsSD <- sqrt( 1 / ObservationPrecision)
pop[1] ~ dunif(0.2,1.5)
observed[1] ~ dlnorm(log(pop[1]), ObservationPrecision)
for(Time in 1:(nObs-1))
{
procerr[Time+1] ~ dlnorm(0, ProcessPrecision)
pop[Time+1] <- max(0, r * pop[Time] * (1 - pop[Time] / K) ) * procerr[Time+1]
observed[Time+1] ~ dlnorm(log(pop[Time+1]), ObservationPrecision)
}
}
",fill = TRUE)
sink()
########################################################################
# Modifield model with "resetting" of the state space to avoid biasing
# estimations by wrong state estimates due to the chaotic behavior
# behavior of the model
# Save BUGS description of the model to working directory
sink("model2.txt")
cat(
"model{
# Prior distributions
r ~ dunif(1,5)
K ~ dunif(0.5,1.5)
ProcessPrecision <- 1/0.005/0.005
ObservationPrecision ~ dunif(1,40)
obsSD <- sqrt( 1 / ObservationPrecision)
for(i in 1:steps)
{
pop[1,i] ~ dunif(0.2,1.5)
observed[1,i] ~ dlnorm(log(pop[1,i]), ObservationPrecision)
for(j in 1:(substeps-1))
{
procerr[j,i] ~ dlnorm(0, ProcessPrecision)
pop[j+1,i] <- max(0, r * pop[j,i] * (1 - pop[j,i] / K) ) * procerr[j,i]
observed[j+1,i] ~ dlnorm(log(pop[1+j,i]), ObservationPrecision)
}
}
}
",fill = TRUE)
sink()
####################################################################
# Testing
# inputs original
data = list(observed = observed[1:(sampleSize+1)], nObs=sampleSize)
params = c("r", "K", "obsSD", "pop[1]") # Parameters to be monitored
jagsModel = jags.model( file= "model.txt", data=data, n.chains = 1, n.adapt= 10000)
results = coda.samples( jagsModel , variable.names=params,n.iter=10000, thin = 10)
plot(results)
# inputs modified
data = list(observed = matrix(observed[1:sampleSize], nrow=5), steps=10, substeps = 5)
params = c("r", "K", "obsSD", "pop[1,1]") # Parameters to be monitored
jagsModel = jags.model( file= "model2.txt", data=data, n.chains = 1, n.adapt= 1000)
results = coda.samples( jagsModel , variable.names=params,n.iter=10000, thin = 10)
plot(results)
####################################################################
# doing the fit for 100 test datasets
library(modeest)
sel <- sample(1:999,100,replace=T) # for selecting parameters from the posterior
posteriormodes <- matrix(nrow = 100, ncol = 4)
posteriorrandom <- matrix(nrow = 100, ncol = 4)
##################################################
# Original model
params = c("r", "K", "obsSD", "pop[1]") # Parameters to be monitored
# Fixed r
for (i in 1:100){
observed <- truepops[i,1:50]
data = list(observed = observed, nObs=sampleSize)
jagsModel = jags.model( file= "model.txt", data=data, n.chains = 1, n.adapt= 10000)
results = coda.samples( jagsModel , variable.names=params,n.iter=10000, thin = 10)
posteriormodes[i,] <- apply(results[[1]],2,venter)
posteriorrandom[i,] <- results[sel[i],][[1]]
}
##################################################
# Modified model
params = c("r", "K", "obsSD", "pop[1,1]") # Parameters to be monitored
# Fixed r
for (i in 1:100){
observed <- truepops[i,1:50]
data = list(observed = matrix(observed, nrow=5), steps=10, substeps = 5)
jagsModel = jags.model( file= "model2.txt", data=data, n.chains = 1, n.adapt= 10000)
results = coda.samples( jagsModel , variable.names=params,n.iter=10000, thin = 10)
posteriormodes[i,] <- apply(results[[1]],2,venter)
posteriorrandom[i,] <- results[sel[i],][[1]]
}
model2results <- list(fixedmodes = posteriormodes, fixedrandom = posteriorrandom)
# Varying r
for (i in 1:50){
observed <- truepops[i,1:50]
data = list(observed = matrix(observed, nrow=5), steps=10, substeps = 5)
jagsModel = jags.model( file= "model2.txt", data=data, n.chains = 1, n.adapt= 10000)
results = coda.samples( jagsModel , variable.names=params,n.iter=10000, thin = 10)
posteriormodes[i,] <- apply(results[[1]],2,venter)
posteriorrandom[i,] <- results[sel[i],][[1]]
}
model2results[["varyrmodes"]] <- posteriormodes[1:50,]
model2results[["varyrrandom"]] <- posteriorrandom[1:50,]
# Plot for the "Fitted" model
error <- matrix(nrow = 100, ncol = sampleSize)
plot(pop[51:100],type="n",ylim =c(0,1), xlab = "Time interval", ylab = "Population size", main = "")
for (i in 1:100){
observed <- truepops[i,51:100]
par <- posteriormodes[i,]
predicted <- logistic(par[1],par[4],observed[1],50)
error[i,] <- (predicted - observed)^2
lines(logistic(trueK,trueR,truepops[1,51],sampleSize), col="#DDDDDD80")
}
lines(logistic(trueK,trueR,truepops[1,51],sampleSize))
prederror <- sqrt(apply(error, 2, mean)) / sd(as.vector(pops))
erroruncertainty <- apply(error, 2, sd)/sqrt(50) / sd(as.vector(pops))
plot(prederror,type = "l")
lines(prederror+erroruncertainty, lty = 2)
lines(prederror-erroruncertainty, lty = 2)
abline(h=1)
hist(model2results$fixedmodes[,4])
hist(model2results$fixedmodes[,4])
hist(model2results$fixedmodes[,4], xlab = "estimated posterior mode", ylab = "", freq = F)
hist(model2results$fixedmodes[,4], xlab = "estimated posterior mode", ylab = "a", freq = T)
hist(model2results$fixedmodes[,4], xlab = "estimated posterior mode", ylab = "a", freq = F)
hist(model2results$fixedmodes[,4], xlab = "estimated posterior mode", ylab = "a", freq = FALSE)
hist(model2results$fixedmodes[,4], xlab = "estimated posterior mode", ylab = "a", freq = FALSE)
hist(model2results$fixedmodes[,4], freq = FALSE, xlab = "estimated posterior mode", ylab = "a")
hist(model2results$fixedmodes[,4], freq = F)
hist(model2results$fixedmodes[,4], freq = T)
hist(model2results$fixedmodes[1:10,4], freq = T)
hist(model2results$fixedmodes[1:10,4], freq = T, xlab = "estimated posterior mode", ylab = "a")
hist(model2results$fixedmodes[1:10,4], freq = F, xlab = "estimated posterior mode", ylab = "a")
hist(model2results$fixedmodes[,4], freq = F, xlab = "estimated posterior mode", ylab = "a")
hist(model2results$fixedmodes[,4], freq = F, xlab = "estimated posterior mode", ylab = "a", main = "")
hist(model2results$fixedmodes[,4], freq = F, xlab = "Posterior mode of estimated growt rates r", ylab = "probability", main = "")
hist(model2results$fixedmodes[,4], freq = F, xlab = "Posterior mode of estimated growt rates r", ylab = "probability density", main = "")
plot(trueRArray, model2results$varyrmodes[,4], ylab = "Posterior mode of estimated growt rates r", xlab = "True r", main = "")
# Varying r
for (i in 1:50){
observed <- truepops2[i,1:50]
data = list(observed = matrix(observed, nrow=5), steps=10, substeps = 5)
jagsModel = jags.model( file= "model2.txt", data=data, n.chains = 1, n.adapt= 10000)
results = coda.samples( jagsModel , variable.names=params,n.iter=10000, thin = 10)
posteriormodes[i,] <- apply(results[[1]],2,venter)
posteriorrandom[i,] <- results[sel[i],][[1]]
}
model2results[["varyrmodes"]] <- posteriormodes[1:50,]
model2results[["varyrrandom"]] <- posteriorrandom[1:50,]
plot(trueRArray, model2results$varyrmodes[,4], ylab = "Posterior mode of estimated growt rates r", xlab = "True r", main = "")
abline(a=1)
abline(a=1,b=0)
abline(a=0,b=1)
# Histogram of the fitted R
plot(trueRArray, model2results$varyrmodes[,4], ylab = "Posterior mode of estimated growt rates r", xlab = "True r", main = "")
abline(a=0,b=1)
plot(trueRArray, model2results$varyrmodes[,4], ylab = "Posterior mode of estimated growt rates r", xlab = "True r", main = "Estimated vs. true r")
abline(a=0,b=1)
version()
R.Version()
# Predictive accuracy for the "Fitted" model
error <- matrix(nrow = 100, ncol = sampleSize)
plot(pop[51:100],type="n",ylim =c(0,1), xlab = "Time interval", ylab = "Population size", main = "")
for (i in 1:100){
observed <- truepops[i,51:100]
par <- posteriormodes[i,]
predicted <- logistic(par[1],par[4],observed[1],50)
error[i,] <- (predicted - observed)^2
lines(logistic(trueK,trueR,truepops[1,51],sampleSize), col="#DDDDDD80")
}
lines(logistic(trueK,trueR,truepops[1,51],sampleSize))
prederror <- sqrt(apply(error, 2, mean)) / sd(as.vector(pops))
erroruncertainty <- apply(error, 2, sd)/sqrt(50) / sd(as.vector(pops))
plot(prederror,type = "l")
lines(prederror+erroruncertainty, lty = 2)
lines(prederror-erroruncertainty, lty = 2)
abline(h=1)
# Predictive accuracy for the "Fitted" model
error <- matrix(nrow = 100, ncol = sampleSize)
plot(pop[51:100],type="n",ylim =c(0,1), xlab = "Time interval", ylab = "Population size", main = "")
for (i in 1:100){
observed <- truepops[i,51:100]
par <- posteriormodes[i,]
predicted <- logistic(par[1],par[4],observed[1],50)
error[i,] <- (predicted - observed)^2
lines(logistic(trueK,trueR,truepops[1,51],sampleSize), col="#DDDDDD80")
}
lines(logistic(trueK,trueR,truepops[1,51],sampleSize))
prederror <- sqrt(apply(error, 2, mean)) / sd(as.vector(truepops[,51:100]))
erroruncertainty <- apply(error, 2, sd)/sqrt(50) / sd(as.vector(truepops[,51:100]))
plot(prederror,type = "l")
lines(prederror+erroruncertainty, lty = 2)
lines(prederror-erroruncertainty, lty = 2)
abline(h=1)
# Predictive accuracy for the "Fitted" model
error <- matrix(nrow = 100, ncol = sampleSize)
plot(pop[51:100],type="n",ylim =c(0,1), xlab = "Time interval", ylab = "Population size", maing = "Predictive uncertainty, fitted models")
for (i in 1:100){
observed <- truepops[i,51:100]
par <- posteriormodes[i,]
predicted <- logistic(par[1],par[4],observed[1],50)
error[i,] <- (predicted - observed)^2
lines(logistic(trueK,trueR,truepops[1,51],sampleSize), col="#DDDDDD80")
}
lines(logistic(trueK,trueR,truepops[1,51],sampleSize))
prederror <- sqrt(apply(error, 2, mean)) / sd(as.vector(truepops[,51:100]))
erroruncertainty <- apply(error, 2, sd)/sqrt(50) / sd(as.vector(truepops[,51:100]))
plot(prederror,type = "l", main = "Predictive error, fitted models")
lines(prederror+erroruncertainty, lty = 2)
lines(prederror-erroruncertainty, lty = 2)
abline(h=1)
# Predictive accuracy for the "Fitted" model
error <- matrix(nrow = 100, ncol = sampleSize)
plot(pop[51:100],type="n",ylim =c(0,1), xlab = "Time interval", ylab = "Population size", main = "Predictive uncertainty, fitted models")
for (i in 1:100){
observed <- truepops[i,51:100]
par <- posteriormodes[i,]
predicted <- logistic(par[1],par[4],observed[1],50)
error[i,] <- (predicted - observed)^2
lines(logistic(trueK,trueR,truepops[1,51],sampleSize), col="#DDDDDD80")
}
lines(logistic(trueK,trueR,truepops[1,51],sampleSize))
# Predictive accuracy for the "TRUE" model
error <- matrix(nrow = 100, ncol = sampleSize)
plot(pop[51:100],type="n",ylim =c(0,1), xlab = "Time interval", ylab = "Population size", main = "Predictive uncertainty, identical models")
for (i in 1:100){
observed <- truepops[i,51:100]
predicted <- logistic(trueK,trueR,truepops[i,51],sampleSize)
error[i,] <- (predicted - observed)^2
lines(logistic(trueK,trueR,truepops[1,51],sampleSize), col="#DDDDDD80")
}
lines(logistic(trueK,trueR,truepops[1,51],sampleSize))
prederror <- sqrt(apply(error, 2, mean)) / sd(as.vector(truepops[,51:100]))
erroruncertainty <- apply(error, 2, sd)/sqrt(50) / sd(as.vector(truepops[,51:100]))
plot(prederror,type = "l", xlab = "Time interval", ylab = "Point-wise RMSE / Population SD", main = "Predictive error, identical models")
lines(prederror+erroruncertainty, lty = 2)
lines(prederror-erroruncertainty, lty = 2)
abline(h=1)
model1results
rlnorm
mean(rlnomr(1000,log(3)))
mean(rlnorm(1000,log(3)))
mean(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(1000,log(100)))
median(rlnorm(100000,log(100)))
median(rlnorm(100000,log(100)))
median(100*rlnorm(100000))
mean(100*rlnorm(100000))
install.packages("spgrass6")
library(ROCR)
?predictions
?prediction
# e.g.
# test data
n<-c(4,1,8,4)        # total number
ill<-c(2,0,1,4)      # success
r1<-c(0.3,0,0.6,0.5) # response 1
r2<-c(0.2,0,0.4,0.7) # response 2
r3<-c(0,0,0.2,0.1)   # response 3
df.t<- data.frame(ill,n,r1,r2,r3)
df.t<- data.frame(ill,n,r1)
#> df.t
#  ill n  r1  r2  r3
#1   2 4 0.3 0.2 0.0
#2   0 1 0.0 0.0 0.0
#3   1 8 0.6 0.4 0.2
#4   4 4 0.5 0.7 0.1
untangleBinomial<-function(x){
df<-x
df$y<-df[,1]/df[,2]
df.new<-data.frame(matrix(0,nrow=sum(df[,2]),ncol=(ncol(df)))) # last colum will be binary original response (df$y)
j=1 # iteration for df.new
for(i in 1:nrow(df)){
# total observation = 1 -> simply copy all cells
if(df[i,2]==1){df.new[j,]<-df[i,];j=j+1}
######################################################
if(df[i,2]>1){ # total observation > 1
z<-df[i,2] # number of rows in new data.frame
df.new[j:(j+z-1),]<-df[rep(i,each=z),]
# check if all rows sum up to 0
if(as.numeric(apply(df[i,3:ncol(df)],1,sum))!=0){
#calculation of 1's and 0's
ones<-apply(df[i,3:ncol(df)],2, function(x) round(z*x)) # response columns with how many ones?
ones.list<-sapply(ones,function(x) rep(1,x)) # convert ones to a list
ones.df<-sapply(ones.list,"[",1:z) # data.frame with 1's and Na's
ones.df[is.na(ones.df)]<-0
df.new[j:(j+z-1),3:ncol(df)]<-ones.df
j=j+z
}
}
########################################################
print(i)
}
colnames(df.new)[1:2]<-c("illsum","Nsum")
return(df.new)
}
untangleBinomial(n)
untangleBinomial(df.t)
df.t
untangleBinomial<-function(x){
df<-x
df.new<-data.frame(matrix(0,nrow=sum(df[,2]),ncol=(ncol(df)))) # last colum will be binary original response (df$y)
j=1 # iteration for df.new
for(i in 1:nrow(df)){
# total observation = 1 -> simply copy all cells
if(df[i,2]==1){df.new[j,]<-df[i,];j=j+1}
######################################################
if(df[i,2]>1){ # total observation > 1
z<-df[i,2] # number of rows in new data.frame
df.new[j:(j+z-1),]<-df[rep(i,each=z),]
# check if all rows sum up to 0
if(as.numeric(apply(df[i,3:ncol(df)],1,sum))!=0){
#calculation of 1's and 0's
ones<-apply(df[i,3:ncol(df)],2, function(x) round(z*x)) # response columns with how many ones?
ones.list<-sapply(ones,function(x) rep(1,x)) # convert ones to a list
ones.df<-sapply(ones.list,"[",1:z) # data.frame with 1's and Na's
ones.df[is.na(ones.df)]<-0
df.new[j:(j+z-1),3:ncol(df)]<-ones.df
j=j+z
}
}
########################################################
print(i)
}
colnames(df.new)[1:2]<-c("illsum","Nsum")
return(df.new)
}
untangleBinomial(df.t)
rep
?rep
plot(airmies)
plot(airmiles)
write.table(airmiles, file="airmiles.txt")
str(airmiles)
airmiles <- read.table("D:/home/Teaching/0_Lectures/2013/13-10-20_ResearchSkills/Material/R/airmiles.txt", header=T, quote="\"")
viewData(airmiles)
airmiles
str(airmies)
str(airmiles)
getwd()
setwd("D:/home/Teaching/0_Lectures/2013/13-10-20_ResearchSkills/Material/R")
write.table(airquality, file="airquality.txt")
airquality <- read.table("D:/home/Teaching/0_Lectures/2013/13-10-20_ResearchSkills/Material/R/airquality.txt", header=T, quote="\"")
viewData(airquality)
rstudio::viewData(airquality)
rstudio::viewData(airquality)
str(airquality)
summary(airquality)
plot(airquality)
airquality$Ozone
airquality[1,]
airquality[,1]
plot(airquality)
plot(airquality$Solar.R, airquality$Temp)
plot(airquality$Ozone, airquality$Temp)
hist(airquality$Ozone)
?hist
hist(airquality$Ozone, breaks = 30, col = "green")
hist(airquality$Ozone, breaks = 30, col = "darkpurple")
hist(airquality$Ozone, breaks = 30, col = "purple")
hist(airquality$Ozone, breaks = 30, col = "bordeaux")
hist(airquality$Ozone, breaks = 30, col = "darkred")
plot(airquality$Ozone, airquality$Temp, pch = 5)
plot(airquality$Ozone, airquality$Temp, pch = 5, size = airquality$Wind)
plot(airquality$Ozone, airquality$Temp, pch = 5, cex.pch = airquality$Wind)
plot(airquality$Ozone, airquality$Temp, pch = 5, cex = airquality$Wind)
plot(airquality$Ozone, airquality$Temp, pch = 5, cex = airquality$Wind / 10)
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10)
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10, col = "darkgreen")
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10, col = "darkred")
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 5, col = "darkred")
plot(airquality$Ozone, airquality$Temp, pch = 2, cex = airquality$Wind / 5, col = "darkred")
plot(airquality$Ozone, airquality$Temp, pch = 2, cex = airquality$Wind / 10, col = "darkred")
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10, col = "darkred")
fit = lm(airquality$Temp~airquality$Ozone)
abline(myline.fit)
abline(fit, col = "blue")
fit = lm(airquality$Temp~airquality$Ozone*airquality$Ozone)
fit
fit = lm(airquality$Temp~airquality$Ozone^2)
fit
fit = lm(airquality$Temp~airquality$Ozone*airquality$Ozone)
fit
fit = lm(airquality$Temp~airquality$Ozone + I(airquality$Ozone^2))
abline(fit, col = "green")
fit = lm(airquality$Temp~airquality$Ozone + I(airquality$Ozone^2))
fit
fit2 = lm(airquality$Temp~airquality$Ozone + I(airquality$Ozone^2))
abline(fit2, col = "green")
line(predict(fit2))
predict(fit2)
str(predict(fit2))
lines(predict(fit2))
lines(predict(fit2)[,1])
lines(predict(fit2))
x = predict(fit2)
x
lines(x)
lines(airquality$Ozone, x, col = "red")
lines(airquality$Ozone, x, col = "red")
airquality$Ozone
lengt(airquality$Ozone)
length(airquality$Ozone)
length(x)
x = predict(fit2, data = 1:150)
lines(1:150, x)
lines(1:150, x)
x
x = predict(fit2, data = 1:150)
x = predict(fit2, newdata = 1:150)
x = predict(fit2, newdata = c(1:150))
x = predict(fit2, newdata = data.frame(1:150))
x = predict(fit2)
lines(na.rm(airquality$Ozone), x)
x = predict(fit2)
plot(x)
plot(airquality$Ozone, x)
plot(airquality$Ozoned[!is.na(airquality$Ozoned)], x)
plot(airquality$Ozoned[!is.na(airquality$Ozone)], x)
plot(airquality$Ozone[!is.na(airquality$Ozone)], x)
plot(airquality$Ozone, airquality$Temp, pch = 5, cex.pch = airquality$Wind)
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10, col = "darkred")
plot(airquality$Ozone[!is.na(airquality$Ozone)], x)
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10, col = "darkred")
lines(airquality$Ozone[!is.na(airquality$Ozone)], x)
plot(airquality$Ozone, airquality$Temp, pch = 3, cex = airquality$Wind / 10, col = "darkred")
points(airquality$Ozone[!is.na(airquality$Ozone)], x)
newdata = data.frame(Ozone = 150)
x = predict(fit2, newdata = newdata)
fit2
str(fit2)
x = predict(fit2, newdata = data.frame("Ozone"=1:150))
x = predict(fit2, newdata = data.frame("Ozone"=1:153))
plot(1:153,x)
x = predict(fit2, newdata = data.frame("Ozone"=c(1:150)))
x = predict(fit2, newdata = data.frame("Ozone"=c(1:150)))
airquality
# Simple Bar Plot
counts <- table(mtcars$gear)
barplot(counts, main="Car Distribution",
xlab="Number of Gears")
# Grouped Bar Plot
counts <- table(mtcars$vs, mtcars$gear)
barplot(counts, main="Car Distribution by Gears and VS",
xlab="Number of Gears", col=c("darkblue","red"),
legend = rownames(counts), beside=TRUE)
x = predict(fit2, newdata = data.frame("Ozone" = 1:150))
x = predict(fit2, newdata = data.frame(airquality$Ozone = 1:153))
x = predict(fit2, newdata = data.frame(Ozone = 1:150))
x = predict(fit2, newdata = data.frame(Ozone = 1:150))
fit2
data(fit2)
fit2$data
str(fit2)
x = predict(fit2, newdata = data.frame("airquality$Ozone" = 1:150))
x = predict(fit2, newdata = 1:150))
x = predict(fit2, newdata = c(1:150))
x = predict(fit2, newdata = 1:150)
x = predict(fit2, newdata = data.frame(Ozone = 1:150))airquality$Ozone
airquality2 = airquality
